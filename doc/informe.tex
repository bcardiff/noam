\documentclass[a4paper,10pt]{article}
\usepackage{a4wide}
\usepackage{caratula}
\usepackage[pdftex]{graphicx}
\usepackage[spanish]{babel}
\usepackage[latin1]{inputenc}
\usepackage{listings}
\usepackage{makeidx} 
\makeindex

\newcommand{\fileh}[1]{\noindent\textsf{Archivo: }\texttt{#1} \hfill\ }
\newcommand{\jc}[1]{\texttt{#1}} % TODO make ref

\begin{document}

\titulo{Noam}
\subtitulo{Conversiones entre formalismos de lenguajes}
\fecha{17 de Julio de 2008}
\materia{Teoría de Lenguajes}
\integrante{Cardiff, Brian Jonathan}{784/03}{bcardiff@gmail.com}
\integrante{Savoretti, Sonia Florencia}{785/03}{soniaflorencia@gmail.com}
\integrante{Geier, Maximiliano Iván}{477/04}{migeier@gmail.com}

\maketitle

\tableofcontents

\section{Conversiones entre formalismos}

El siguiente gráfico muestra los algoritmos implementados para convertir de un 
formalismo a otro. 

\begin{center}
\includegraphics[width=6.5cm]{conversiones.png}
\end{center}

Luego, por ejemplo para convertir de ER a AFM se realizan las conversiones
intermedias a AF y a AFD. En el caso de AFM a AFD o AF no se realiza conversión alguna, 
así como tampoco para AFD a AF.

Para los casos de formalismos de entrada AFD y AFM, se toma como válida
la entrada si corresponde exactamente con dicho formalismo.

A continuación se hacen comentarios sobre los distintos algoritmos de conversión.

\subsection{AF a AFD. Determinizar}

Se aplica directamente la eliminación de transiciones lambda y la determinización
del autómata. Se implementa en \jc{Determination}.

\subsection{AFD a AFM. Minimizar}

Luego de completar el AFD usando \jc{Complete} y eliminar los estados no alcanzables usando
\jc{Reachables}, se aplica el algoritmo de minimización visto en clase e implementado en \jc{Minimization}.

Como resultado de la minimización es posible que se generen autómatas sin estados finales. 
Elegimos contemplar la generación de los autómatas sin estados finales, por más que no
sean parte de la gramática. Claramente ésto se presenta cuando el lenguaje que se describe
es $\emptyset$ ej.:  VACIO, VACIO.a.

\subsection{AFD a ER}

Se implementa el algoritmo recursivo que plantea $R^k_{ij}$ como el lenguaje regular que se
obtiene desde el estado $s_i$ al estado $s_j$ pasando a lo sumo por $s_1, \ldots, s_k$ como estados intermedios.

La implementación se encuentra en \jc{AFDtoER}.

A medida que se generan los resultados intermedios se le aplican algunas simplificaciones: 

\begin{itemize}
\item $\emptyset | r = r$
\item $r | \emptyset = r$
\item $\lambda | \lambda = \lambda$
\item $\emptyset . r = \emptyset$
\item $r . \emptyset = \emptyset$
\item $\lambda . r = r$
\item $r . \lambda = r$
\item $\emptyset^* = \lambda$
\item $\lambda^* = \lambda$
\end{itemize}

\subsection{ER a AF}

Se hace una transformación recursiva en la estructura de la ER basada en la demostración
de inclusión de lenguajes aceptados por expresiones regulares en los aceptados 
por autómatas finitos del Hopcroft et.al..

La única diferencia es el caso de la clausura. En lugar de agregar un estado final y uno inicial, se preserva
el estado inicial, se agregan transiciones lambda desde todos los finales al inicial, y se define al estado inicial
como único estado final.

La implementación se encuentra en \jc{ERToAutomata}.

\subsection{AFD a GR}

Se implementa un algoritmo que transforma el autómata de la siguiente forma:

\begin{itemize}
\item El estado inicial se convierte en el símbolo distinguido de la gramática.
\item Cada estado se convierte en un símbolo no terminal.
\item Cada transición $(q_A, t, q_B)$ se convierte en una producción de la forma $A \rightarrow tB$.
\item Se agrega una producción $A \rightarrow \lambda$ por cada $q_A$ que sea estado final del autómata.
\end{itemize}

La implementación se encuentra en \jc{AFToGr}.

\subsection{GR a AF}

Como las gramáticas tratadas son recursivas simples a derecha la transformación se pone
un estado $q_A$ por cada símbolo no terminal $A$, el estado inicial se corresponde con el 
símbolo distinguido, se agregar un estado final $q_f$ (que no se
corresponde con ningún símbolo no terminal) y cada producción se traduce como sigue:

\begin{description}
\item[$A \rightarrow \lambda$] se agrega el estado $q_A$ como estado final y una transición
	desde $q_A$ hacia el mismo estado por $\lambda$. %TODO porque esta transicion?
\item[$A \rightarrow tB$] se agrega una transición con label $t$ desde $q_A$ hacia $q_B$.
\item[$A \rightarrow t$] se agrega a una transición con label $t$ desde $q_A$ hacia $q_f$.
\end{description}

\section{Ejemplos}

Se muestra la conversión de $a.(a|b)^*$ a AFD y AFM.

\begin{verbatim}
#> java -jar noam.jar -i ER -o AFD
a.(a|b)*
^Z
<(A,B,C,D),(a,b),((A,a,A)(A,b,D)(B,a,C)(C,a,A)(C,b,D)(D,a,A)(D,b,D)),B,(A,C,D)>
\end{verbatim}

La salida se corresponde con:

\begin{center}
\includegraphics[width=3.5cm]{ejemplo1.png}
\end{center}

\begin{verbatim}
#> java -jar noam.jar -i ER -o AFM
a.(a|b)*
^Z
<(A,B,C),(a,b),((A,a,A)(A,b,A)(B,a,C)(B,b,A)(C,a,C)(C,b,C)),B,(C)>
\end{verbatim}

La salida se corresponde con:

\begin{center}
\includegraphics[width=6cm]{ejemplo2.png}
\end{center}

\section{Desarrollo}

El desarrollo del proyecto se realizó con Eclipse 3.2. Se usaron las siguientes bibliotecas y plug-ins de eclipse:

\begin{description}
\item[antlr-eclipse] \verb"http://antlreclipse.sourceforge.net/" plug-in de eclipse con soporte para
edición y compilación integrada de gramáticas AntLR 2.7.6 .
\item[JUnit4]
\item[java-getopt] biblioteca incluida en \verb"/lib" para el tratamiento de argumentos por línea de comandos.
\item[FatJar] \verb"http://fjep.sourceforge.net/" plug-in de eclipse para generar un jar sin dependencias.
\end{description}

Dado que se usó FatJar, para usar la aplicación lo único necesario es ejecutar

\begin{verbatim}
#> java -jar noam.jar -i <GR|ER|AF|AFD|AFM> [-o <GR|ER|AF|AFD|AFM> [-d]]
\end{verbatim}

El parámetro \verb"-d" es para imprimir el autómata resultante en formato dot.

\section{Descripción por package}
\input{package-doc}

\section{Código fuente AntLR}
\lstset{numbers=left, frame=single, tabsize=2, breaklines=true}
\input{source-code-antlr}

\section{Código fuente Java}
\lstset{language=Java, numbers=left, frame=single, tabsize=2, breaklines=true}
\input{source-code-java}

\addcontentsline{toc}{section}{Index}
\printindex 

\end{document}
